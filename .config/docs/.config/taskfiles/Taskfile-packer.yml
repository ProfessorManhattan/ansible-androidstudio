---
version: '3'

vars:
  TEMPLATE_FILE:
    sh: if [ ! -z "{{.CLI_ARGS}}" ]; then echo "{{.CLI_ARGS}}"; else echo "template.packer.json"; fi
  VARIABLES_PATH: .variables.json

tasks:
  build:all:
    deps:
      - :install:software:kvm
      - :install:software:packer
      - :install:software:parallels
      - :install:software:virtualbox
      - :install:software:vmware
    desc: Build Packer images for all platforms (default setting uses `template.json`)
    summary: |
      # Build Packer images for all virtualization platforms

      This task begins by removing cached files that may interfere with the Packer build
      process. It then runs `packer build template.json` if no arguments are passed. This
      command will build Packer images for all the virtualization platforms specified in
      the template file. The template file may include instructions for the following
      virtualization platforms (and it is possible that it includes other ones that are
      not listed below):

      * Hyper-V
      * KVM
      * Parallels
      * VMWare
      * VirtualBox

      If you would like to build machine images with another template then you can pass the
      template's file name as a parameter (see example below).

      **Example building on all platforms:**
      `task build:all`

      **Example using a template file named `another_template.json`:**
      `task build:all -- another_template.json`
    cmds:
      - packer build {{.TEMPLATE_FILE}}

  build:kvm:
    deps:
      - :install:software:kvm
      - :install:software:packer
    desc: Build a Packer image for KVM
    summary: |
      # Build a Packer image for KVM

      This task will build a machine image intended to be used by KVM environments. KVM
      environments are generally only available on Linux (although, it is supposedly
      possible to run KVM on macOS as well). By default, this task assumes the template
      file is titled `template.json` and that the file is in the root of the project. If
      you would like to use another template file then you can do so by passing the file
      name as a parameter (see example below).

      **Example:**
      `task build:kvm`

      **Example using a template file named `another_template.json`:**
      `task build:kvm -- another_template.json`
    cmds:
      - packer build -only=qemu {{.TEMPLATE_FILE}}

  build:parallels:
    deps:
      - :install:software:packer
      - :install:software:parallels
    desc: Build a Packer image for Parallels
    summary: |
      # Build a Packer image for Parallels

      This task will build a machine image intended to be used by Parallels. Parallels
      is only available for macOS. By default, this task assumes the template file is
      titled `template.json` and that the file is in the root of the project. If you
      would like to use another template file then you can do so by passing the file
      name as a parameter (see example below).

      **Example:**
      `task build:parallels`

      **Example using a template file named `another_template.json`:**
      `task build:parallels -- another_template.json`
    cmds:
      - packer build -only=parallels-iso {{.TEMPLATE_FILE}}

  build:virtualbox:
    deps:
      - :install:software:packer
      - :install:software:virtualbox
    desc: Build a Packer image for VirtualBox
    summary: |
      # Build a Packer image for VirtualBox

      This task will build a machine image intended to be used by VirtualBox. By
      default, this task assumes the template file is titled `template.json` and
      that the file is in the root of the project. If you would like to use another
      template file then you can do so by passing the file name as a parameter
      (see example below).

      **Example:**
      `task build:virtualbox`

      **Example using a template file named `another_template.json`:**
      `task build:virtualbox -- another_template.json`
    cmds:
      - packer build -only=virtualbox-iso {{.TEMPLATE_FILE}}

  latestos:
    deps:
      - :install:python:requirements
      - :install:software:jq
    vars:
      TAG:
        sh: jq -r '.variables.latestos_tag' template.json
    cmds:
      - |
        if [ "${container:=}" != 'docker' ] && [[ '{{.TAG}}' != 'macos' ]]; then # TODO: Only generate if latestos wasn't run recently
          latestos {{.TAG}}
        fi
    status:
      - '[[ "{{.TAG}}}" == "macos" ]] || [ "${container:=}" == "docker" ]'
    preconditions:
      - sh: test -f template.json
        msg: The `template.json` file is missing from the root of this project.

  packer:vmware:
    deps:
      - :install:software:packer
      - :install:software:vmware
    desc: Build a Packer image for VMWare
    summary: |
      # Build a Packer image for VMWare

      This task will build a machine image intended to be used by VMWare. The image
      build can be used by either VMWare Workstation (i.e. Linux, Windows) or by
      VMWare Fusion (i.e. macOS). By default, this task assumes the template file is
      titled `template.json` and that the file is in the root of the project. If you
      would like to use another template file then you can do so by passing the file
      name as a parameter (see example below).

      **Example:**
      `task packer:vmware`

      **Example using a template file named `another_template.json`:**
      `task packer:vmware -- another_template.json`
    cmds:
      - packer build -only=vmware-iso {{.TEMPLATE_FILE}}

  update:descriptions:
    deps:
      - :install:software:jq
    env:
      DESCRIPTION_TEMPLATE:
        sh: jq -r '.description_template' '{{.VARIABLES_PATH}}'
      TMP:
        sh: mktemp
      VERSION_DESCRIPTION:
        sh: jq -r '.version_description' '{{.VARIABLES_PATH}}'
    cmds:
      - jq --arg a "$DESCRIPTION_TEMPLATE" --arg b "$VERSION_DESCRIPTION" '.variables.description = $a | .variables.version_description = $b'
        template.packer.json > "$TMP"
      - mv "$TMP" template.json
    sources:
      - template.json
      - '{{.VARIABLES_PATH}}'

  update:readme:
    cmds:
      - task: update:readme:platform
        vars:
          TYPE: hyperv-iso
      - task: update:readme:platform
        vars:
          TYPE: parallels-iso
      - task: update:readme:platform
        vars:
          TYPE: qemu
      - task: update:readme:platform
        vars:
          TYPE: virtualbox-iso
      - task: update:readme:platform
        vars:
          TYPE: vmware-iso

  update:readme:platform:
    cmds:
      - task: update:readme:platform:{{OS}}
    status:
      - |
        ! grep -q '"type": "{{.TYPE}}"' template.packer.json

  update:readme:platform:darwin: sed -i .bak '/SUPPORTED_OS_{{.TYPE}}/d' README.md && rm README.md.bak

  update:readme:platform:linux: sed -i '/SUPPORTED_OS_{{.TYPE}}/d' README.md

  update:variables:
    deps:
      - :install:software:jq
    vars:
      ISO_VERSION:
        sh: jq -r '.variables.iso_version' template.packer.json
      MAJOR_VERSION:
        sh: cut -d '.' -f 1 <<< {{.ISO_VERSION}}
      MINOR_VERSION:
        sh: cut -d '.' -f 2 <<< {{.ISO_VERSION}}
    env:
      TEMPLATE_JSON:
        sh: jq -r '.' template.json
      TMP:
        sh: mktemp
    cmds:
      - jq -S --arg templatejson "$TEMPLATE_JSON" '.template_json = ($templatejson | fromjson)' '{{.VARIABLES_PATH}}' > "$TMP"
      - mv "$TMP" '{{.VARIABLES_PATH}}'
      - task: update:variables:{{OS}}
    sources:
      - template.json
      - '{{.VARIABLES_PATH}}'
    preconditions:
      - sh: test -f template.json
        msg: 'A `template.json` file is not present. This project uses values stored in `template.json` to generate certain
          meta artifacts. Please add a `template.json`. You can find an example of one in
          [this repository](https://gitlab.com/megabyte-labs/packer/ubuntu-desktop)'
      - sh: test -f '{{.VARIABLES_PATH}}'
        msg: 'The `{{.VARIABLES_PATH}}` file is missing!'

  update:variables:darwin:
    cmds:
      - sed -i .bak "s^MAJOR_VERSION^{{.MAJOR_VERSION}}^g" '{{.VARIABLES_PATH}}' && rm '{{.VARIABLES_PATH}}.bak'
      - sed -i .bak "s^MINOR_VERSION^{{.MINOR_VERSION}}^g" '{{.VARIABLES_PATH}}' && rm '{{.VARIABLES_PATH}}.bak'
      - sed -i .bak "s^ISO_VERSION^{{.ISO_VERSION}}^g" '{{.VARIABLES_PATH}}' && rm '{{.VARIABLES_PATH}}.bak'

  update:variables:linux:
    cmds:
      - sed -i "s^MAJOR_VERSION^{{.MAJOR_VERSION}}^g" '{{.VARIABLES_PATH}}'
      - sed -i "s^MINOR_VERSION^{{.MINOR_VERSION}}^g" '{{.VARIABLES_PATH}}'
      - sed -i "s^ISO_VERSION^{{.ISO_VERSION}}^g" '{{.VARIABLES_PATH}}'
