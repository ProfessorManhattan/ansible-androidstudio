---
version: "3"

vars:
  GITHUB_ISSUES: true
  GITHUB_ORG: ProfessorManhattan
  GITHUB_USER: ProfessorManhattan
  GITHUB_WIKI: false
  GITLAB_WIKI: false
  TIMEZONE: America/New_York

env:
  CLICOLOR:
    sh: if [[ "${container:=}" == 'docker' ]]; then echo "0"; else echo "1"; fi

tasks:
  convert-folder-to-submodule:
    deps:
      - github:update
      - gitlab:update
    vars:
      BASENAME:
        sh: basename "$PWD"
      GITLAB_REPO:
        sh: jq -r '.blueprint.repository.gitlab' package.json
    cmds:
      - git init
      - git remote add origin "{{.GITLAB_REPO}}"
      - git add --all
      - git commit -m "refactor(convert-dir-to-submodule) Adding folder/project to its own git repository."
      - git push origin master
      - |
        cd ..
        rm -rf {{.BASENAME}}
        git add {{.BASENAME}}
        git commit -m "refactor(convert-dir-to-submodule) Removing folder which will now be a submodule."
        git submodule add -b master "{{.GITLAB_REPO}}" {{.BASENAME}}
        git add {{.BASENAME}}
        git commit -m "refactor(convert-dir-to-submodule) Adding new submodule which was previously a directory."
        git push -u origin HEAD
      - true success "Converted the `{{.BASENAME}}` directory to a submodule"
    preconditions:
      - sh: '[[ ! $(git rev-parse --git-dir) =~ ".git/modules" ]]'
        msg: Cannot convert the directory to a submodule - the directory already appears to be a submodule.

  github:create:
    deps:
      - :install:software:gh
      - :install:software:jq
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      GITHUB_REPO:
        sh: jq -r '.blueprint.repository.github' package.json
      GITHUB_SLUG:
        sh: jq -r '.name' package.json | sed 's/.*\///'
      HOMEPAGE:
        sh: jq -r '.homepage' package.json
      PROJECT_TYPE:
        sh: if [[ $(jq -r '.private' package.json) == 'true' ]]; then echo '--private'; else echo '--public'; fi
    env:
      TMP:
        sh: mktemp
    run: once
    cmds:
      - |
        if [ ! -z "$GITHUB_TOKEN" ]; then
          gh repo create "{{.GITHUB_SLUG}}" --enable-wiki={{.GITHUB_WIKI}} -y --description "{{.DESCRIPTION}}" --homepage "{{.HOMEPAGE}}" \
            {{.PROJECT_TYPE}} 2>&1 | grep "HTTP 422: Repository creation failed."
          if [[ $? == 0 ]]; then
            true error "GitHub repository `{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}` already exists."
          else
            true success "GitHub repository `{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}` successfully created!"
          fi
          jq --arg repo "https://github.com/{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}" '.blueprint.repository.github = $repo' package.json > "$TMP"
          mv "$TMP" package.json
        else
          true warn "The `GITHUB_TOKEN` environment variable is not set so the GitLab repository cannot be updated via the API."
        fi
    status:
      - '[ "{{.GITHUB_REPO}}" != "null" ]'
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: The `.description` in `package.json` must be set.
      - sh: '[ "{{.GITHUB_SLUG}}" != "null" ]'
        msg: The `.name` in `package.json` must be set.
      - sh: '[ "{{.HOMEPAGE}}" != "null" ]'
        msg: The `.homepage` in `package.json` must be set.

  github:update:
    deps:
      - github:update:meta

  github:update:meta:
    deps:
      - :install:software:gh
      - :install:software:jq
      - github:create
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      HOMEPAGE:
        sh: jq -r '.homepage' package.json
      PRIVATE:
        sh: jq -r '.private' package.json | sed 's/null/false/'
    cmds:
      - |
        if [ ! -z "$GITHUB_TOKEN" ]; then
          gh api -X PATCH repos/{owner}/{repo} -f description="{{.DESCRIPTION}}" -f homepage="{{.HOMEPAGE}}" \
            -f has_issues={{.GITHUB_ISSUES}} -f has_wiki={{.GITHUB_WIKI}} -f private="{{.PRIVATE}}"
        else
          true warn "The `GITHUB_TOKEN` environment variable is not set so the GitHub repository cannot be updated via the API."
        fi
    status:
      - '[ -z "$GITHUB_TOKEN" ]'
    sources:
      - package.json
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: The `.description` in `package.json` must be set.
      - sh: '[ "{{.HOMEPAGE}}" != "null" ]'
        msg: The `.homepage` in `package.json` must be set.

  gitlab:create:
    deps:
      - :install:software:glab
      - :install:software:jq
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      GITLAB_PATH:
        sh: jq -r '.blueprint.gitlab_path' package.json
      GITLAB_REPO:
        sh: jq -r '.blueprint.repository.gitlab' package.json
      NAME:
        sh: jq -r '.blueprint.name' package.json
      PROJECT_TYPE:
        sh: if [[ $(jq -r '.private' package.json) == 'true' ]]; then echo '--private'; else echo '--public'; fi
      TMP:
        sh: mktemp
    env:
      KEYWORDS:
        sh: jq -r '.keywords | tostring' package.json | sed 's/\[//' | sed 's/\]//'
    run: once
    cmds:
      - |
        if [ ! -z "$GITLAB_TOKEN" ]; then
          glab repo create {{.GITLAB_PATH}} --description "{{.DESCRIPTION}}" --name "{{.NAME}}" {{.PROJECT_TYPE}} \
            --tag "$KEYWORDS"
          if [[ $? == 0 ]]; then
            true success "GitLab repository `{{.GITLAB_PATH}}` successfully created!"
          else
            true error "GitLab repository `{{.GITLAB_PATH}}` already exists.
          fi
          jq --arg repo "https://gitlab.com/{{.GITLAB_PATH}}" '.blueprint.repository.gitlab = $repo' package.json > "$TMP"
          mv "$TMP" package.json
        else
          true warn "The `GITLAB_TOKEN` environment variable is not set so the GitLab repository cannot be created."
        fi
    status:
      - '[ "{{.GITLAB_REPO}}" != "null" ]'
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: The `.description` in `package.json` must be set.
      - sh: '[ "{{.GITLAB_PATH}}" != "null" ]'
        msg: The `.blueprint.gitlab_path` variable (e.g. `megabyte-labs/ansible-roles/androidstudio`) in `package.json` must be set.
      - sh: '[ "{{.NAME}}" != "null" ]'
        msg: The `.blueprint.name` variable in `package.json` must be set.

  gitlab:mirror:
    deps:
      - :install:software:glab
      - :install:software:jq
      - github:create
      - gitlab:create
    vars:
      GITHUB_SLUG:
        sh: jq -r '.name' package.json | sed 's/.*\///'
      GITLAB_REPO_ID:
        sh: glab api projects/:fullpath | jq -r '.id'
      PUSH_MIRROR_COUNT:
        sh: glab api projects/:fullpath/remote_mirrors | jq '. | length'
    cmds:
      - >
        if [[ "{{.PUSH_MIRROR_COUNT}}" == '0' ]]; then
          glab api projects/:fullpath/remote_mirrors --method POST --header "Content-Type: application/json"
            -f "url=https://{{.GITHUB_USER}}:$GITHUB_TOKEN@github.com/{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}.git"
            -f 'enabled=true'
        fi
      - cmd: >
          curl -H 'Content-Type: application/json' -H "Authorization: Bearer $GITLAB_TOKEN" -XPUT --data
            "{'mirror': true, 'import_url': 'https://{{.GITHUB_USER}}:$GITHUB_TOKEN@github.com/{{.GITHUB_ORG}}/{{.GITHUB_SLUG}}.git'}"
            'https://gitlab.com/api/v4/projects/{{.GITLAB_REPO_ID}}'
    sources:
      - package.json
    preconditions:
      - sh: '[ ! -z "$GITHUB_TOKEN" ]'
        msg: The `GITHUB_TOKEN` environment variable must be set to enable mirroring.
      - sh: '[ ! -z "$GITLAB_TOKEN" ]'
        msg: The `GITLAB_TOKEN` environment variable must be set to enable mirroring.
      - sh: '[ ! -z "{{.GITLAB_REPO_ID}}" ]'
        msg: Unable to acquire `GITLAB_REPO_ID`. Ensure origin is pointing to GitLab.

  gitlab:pipelines:
    deps:
      - :install:software:glab
      - :install:software:jq
      - gitlab:create
    vars:
      PIPELINE_COUNT:
        sh: jq -r '.gitlab_pipelines | length' .variables.json
    env:
      PIPELINES:
        sh: jq -r '.gitlab_pipelines' .variables.json
      PIPELINE_RES:
        sh: glab api projects/:fullpath/pipeline_schedules
    cmds:
      - |
        if [ ! -z "$GITLAB_TOKEN" ]; then
          MAX_INDEX=$(({{.PIPELINE_COUNT}} - 1))
          for PIPELINE_INDEX in {0..$MAX_INDEX}; do
            ACTIVE=$(echo "$PIPELINES" | jq --arg i "$PIPELINE_INDEX" '.[$i | tonumber].active')
            CRON=$(echo "$PIPELINES" | jq --arg i "$PIPELINE_INDEX" '.[$i | tonumber].cron')
            DESC=$(echo "$PIPELINES" | jq --arg i "$PIPELINE_INDEX" '.[$i | tonumber].description')
            REF=$(echo "$PIPELINES" | jq --arg i "$PIPELINE_INDEX" '.[$i | tonumber].ref')
            if ! $(echo "$PIPELINE_RES") | grep "$DESC"; then
              glab api projects/:fullpath/pipeline_schedules -X POST -f active="$ACTIVE" -f description="$DESC" \
                -f ref="$REF" -f cron="$CRON" -f cron_timezone="{{.TIMEZONE}}"
              true success "Pipeline with description of `$DESC` successfully added"
            else
              true log "Pipeline with description of `$DESC` already added"
          done
          for
        else
          true warn "The `GITLAB_TOKEN` environment variable is not set so the GitLab pipelines cannot be updated via the API."
        fi
    status:
      - '[ -z "$GITLAB_TOKEN" ]'

    sources:
      - .variables.json
  gitlab:update:
    deps:
      - gitlab:mirror
      - gitlab:pipelines
      - gitlab:update:meta
      - gitlab:wiki

  gitlab:update:meta:
    deps:
      - :install:software:glab
      - :install:software:jq
      - gitlab:create
    vars:
      DESCRIPTION:
        sh: jq -r '.description' package.json
      GITLAB_PATH:
        sh: jq -r '.blueprint.gitlab_path' package.json
      GITLAB_REPO:
        sh: jq -r '.blueprint.repository.gitlab' package.json
      NAME:
        sh: jq -r '.blueprint.name' package.json
      PROJECT_TYPE:
        sh: if [[ $(jq -r '.private' package.json) == 'true' ]]; then echo 'private'; else echo 'public'; fi
    env:
      KEYWORDS:
        sh: jq -r '.keywords | tostring' package.json | sed 's/\[//' | sed 's/\]//'
    cmds:
      - |
        if [ ! -z "$GITLAB_TOKEN" ]; then
          glab api projects/:fullpath -X PUT -f description="{{.DESCRIPTION}}" -f name="{{.NAME}}" \
            -f wiki_enabled={{.GITLAB_WIKI}} -f visibility="{{.PROJECT_TYPE}}" -f tag_list="$KEYWORDS"
        else
          true warn "The `GITLAB_TOKEN` environment variable is not set so the GitLab repository cannot be updated via the API."
        fi
    status:
      - '[ -z "$GITLAB_TOKEN" ]'
    sources:
      - package.json
    preconditions:
      - sh: '[ "{{.DESCRIPTION}}" != "null" ]'
        msg: The `.description` in `package.json` must be set.
      - sh: '[ "{{.NAME}}" != "null" ]'
        msg: The `.blueprint.name` variable in `package.json` must be set.
  gitlab:wiki:
    deps:
      - :common:update
      - :install:software:glab
      - :install:software:jq
      - gitlab:create
    vars:
      DOCS_URL:
        sh: jq -r '.docs.link' .variables.json
      GROUP:
        sh: jq -r '.group' .variables.json
    cmds:
      - |
        if [ -z "$GITLAB_TOKEN" ]; then
          glab api projects/:fullpath/services/external-wiki -X PUT -f external_wiki_url="{{.DOCS_URL}}/{{.GROUP}}"
        else
          true warn "The `GITLAB_TOKEN` environment variable is not set so the GitLab repository's external wiki cannot be updated via the API."
        fi
    status:
      - '[ -z "$GITLAB_TOKEN" ]'
    sources:
      - .variables.json
    preconditions:
      - sh: '[ "{{.DOCS_URL}}" != "null" ]'
        msg: The `.docs.link` variable in `.variables.json` must be set.
      - sh: '[ "{{.GROUP}}" != "null" ]'
        msg: The `.group` variable in `.variables.json` must be set.

  remotes:
    deps:
      - :install:software:git
    desc: Configure the git remote `origin` to point to GitLab and the git remote `all` to point to GitLab and GitHub
    summary: |
      # Configure git remote

      This task will set the origin to the GitLab repository associated with this project. It will then also create
      a remote named `all` which will point to both the GitLab repository and the GitHub mirror. You can then
      push to both repositories at the same time by running `git push origin master`.

      **Example usage:**
      `task git:remotes`
    vars:
      GITHUB_REPO:
        sh: jq -r '.blueprint.repository.github' package.json | sed 's/^https:\/\//git@/' | sed 's/github.com\//github.com:/'
      GITLAB_REPO:
        sh: jq -r '.blueprint.repository.gitlab' package.json | sed 's/^https:\/\//git@/' | sed 's/gitlab.com\//gitlab.com:/'
    cmds:
      - |
        if [ ! -z "{{.GITLAB_REPO}}" ]; then
          if git config remote.origin.url; then
            git remote set-url origin "{{.GITLAB_REPO}}.git"
          else
            git remote add origin "{{.GITLAB_REPO}}.git"
          fi
          if git config remote.gitlab.url; then
            git remote set-url gitlab "{{.GITLAB_REPO}}.git"
          else
            git remote add gitlab "{{.GITLAB_REPO}}.git"
          fi
        fi
      - |
        if [ ! -z "{{.GITHUB_REPO}}" ]; then
          if git config remote.github.url; then
            git remote set-url github "{{.GITHUB_REPO}}.git"
          else
            git remote add github "{{.GITHUB_REPO}}.git"
          fi
        fi
      - |
        if [ ! -z "{{.GITLAB_REPO}}" ] && [ ! -z "{{.GITHUB_REPO}}" ]; then
          if git config remote.all.url; then
            git remote rm all
          fi
          git remote add all "{{.GITLAB_REPO}}.git"
          git remote set-url --add --push all "{{.GITHUB_REPO}}.git
          git remote set-url --add --push all "{{.GITLAB_REPO}}.git"
        fi
    status:
      - '[ -z "{{.GITHUB_REPO}}" ]'
      - '[ -z "{{.GITLAB_REPO}}" ]'

    sources:
      - package.json
  remove:submodules:
    deps:
      - :install:software:git
    desc: Remove all submodules in the current directory and optionally filter by RegEx
    summary: |
      # Remove submodules in current directory

      This task will remove all the submodules in the current directory and its' children.
      You can optionally specify RegEx to only remove submodules that match a particular pattern.
      Please note that this task is not _perfect_. You should commit your current changes before using it
      and then reset the repository with `git reset --hard HEAD` if anything pops up on `git status` that
      you do not like after running it.

      **Example removing all submodules that are children of the working directory:**
      `task git:remove-submodules`

      **Example removing all submodules that are children of the working directory and matching a pattern:**
      `task git:remove-submodules -- docs`
    vars:
      GITMODULES_PATH:
        sh: git rev-parse --git-dir | sed 's/\.git\/modules\(.*\)/.gitmodules/' | sed 's/\.git$/.gitmodules/'
      REGEX_ARG:
        sh: if [ -z "{{.CLI_ARGS}}" ]; then echo ""; else echo " | {{.CLI_ARGS}}"; fi
      RELATIVE_PATH:
        sh: pwd | sed "s,^$(git rev-parse --show-toplevel),," | cut -c2-
      TOP_LEVEL:
        sh: git rev-parse --show-toplevel
    cmds:
      - |
        MODULE_PATHS=$(git config --file "{{.GITMODULES_PATH}}" --name-only --get-regexp "{{.RELATIVE_PATH}}"
          | sed 's/^submodule\.//' | grep "path$" | sed 's/\.path$//'{{.REGEX_ARG}})
        for MODULE_PATH in "$MODULE_PATHS"; do
          RELATIVE_PATH=$(echo "$MODULE_PATH" | sed "s,^{{.RELATIVE_PATH}}/,,")
          true log "Removing `$RELATIVE_PATH` submodule"
          git submodule deinit "$RELATIVE_PATH"
          git rm "$RELATIVE_PATH"
          rm -rf "{{.TOP_LEVEL}}/.git/modules/$MODULE_PATH"
        done
