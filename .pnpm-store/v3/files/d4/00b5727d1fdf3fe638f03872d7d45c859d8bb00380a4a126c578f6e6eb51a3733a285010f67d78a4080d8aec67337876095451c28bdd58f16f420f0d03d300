"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const url_1 = require("url");
const tunnel_agent_1 = __importDefault(require("tunnel-agent"));
const TIMEOUT = 10000;
function get(url, options) {
    return get0(url, options, 0);
}
exports.default = get;
function get0(url, options, redirectCount) {
    const client = url.startsWith("https") ? https_1.default : http_1.default;
    const parsedOptions = parseUrlAndOptions(url, options || {});
    return new Promise((resolve, reject) => {
        let result = "";
        const req = client.get(parsedOptions, (res) => {
            res.on("data", (chunk) => {
                result += chunk;
            });
            res.on("end", () => {
                if (res.statusCode &&
                    res.statusCode >= 300 &&
                    res.statusCode < 400 &&
                    redirectCount < 3) {
                    const redirectUrl = res.headers.location;
                    resolve(get0(redirectUrl, options, redirectCount + 1));
                    return;
                }
                resolve(result);
            });
        });
        req.on("error", (e) => {
            reject(e);
        });
        req.setTimeout(TIMEOUT, function handleRequestTimeout() {
            if (req.destroy) {
                req.destroy();
            }
            else {
                req.abort();
            }
            reject(new Error(`Timeout of ${TIMEOUT}ms exceeded`));
        });
    });
}
function parseUrlAndOptions(urlStr, baseOptions) {
    var _a;
    const url = new url_1.URL(urlStr);
    const hostname = typeof url.hostname === "string" && url.hostname.startsWith("[")
        ? url.hostname.slice(1, -1)
        : url.hostname;
    const options = Object.assign(Object.assign({}, baseOptions), { protocol: url.protocol, hostname, path: `${url.pathname || ""}${url.search || ""}` });
    if (url.port !== "") {
        options.port = Number(url.port);
    }
    if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
    }
    const PROXY_ENV = [
        "https_proxy",
        "HTTPS_PROXY",
        "http_proxy",
        "HTTP_PROXY",
        "npm_config_https_proxy",
        "npm_config_http_proxy",
    ];
    const proxyStr = ((_a = options) === null || _a === void 0 ? void 0 : _a.proxy) ||
        PROXY_ENV.map((k) => process.env[k]).find((v) => v);
    if (proxyStr) {
        const proxyUrl = new url_1.URL(proxyStr);
        options.agent = tunnel_agent_1.default[`http${url.protocol === "https:" ? "s" : ""}OverHttp${proxyUrl.protocol === "https:" ? "s" : ""}`]({
            proxy: {
                host: proxyUrl.hostname,
                port: Number(proxyUrl.port),
                proxyAuth: proxyUrl.username || proxyUrl.password
                    ? `${proxyUrl.username}:${proxyUrl.password}`
                    : undefined,
            },
        });
    }
    return options;
}
