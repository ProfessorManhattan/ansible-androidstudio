{"version":3,"sources":["../../src/rules/checkLineAlignment.js"],"names":["flow","commentFlow","transforms","checkNotAlignedPerTag","utils","tag","customSpacings","spacerProps","contentProps","mightHaveNamepath","tagMightHaveNamepath","tokens","source","followedBySpace","idx","callbck","nextIndex","slice","some","spacerProp","innerIdx","contentProp","spacePropVal","ret","ok","contentPropVal","spacerPropVal","spacing","length","fix","entries","padStart","hasSpace","contentPrp","setTag","reportJSDoc","checkAlignment","indent","jsdoc","jsdocNode","preserveMainDescriptionPostDelimiter","report","tags","transform","transformedJsdoc","comment","value","formatted","stringify","trimStart","fixer","replaceText","context","applicableTags","options","includes","foundTags","getPresentTags","iterateAllJsdocs","meta","docs","description","url","fixable","schema","enum","type","additionalProperties","properties","postDelimiter","postName","postTag","postType","default","items"],"mappings":"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","sourcesContent":["import {\n  transforms,\n} from 'comment-parser';\nimport alignTransform from '../alignTransform';\nimport iterateJsdoc from '../iterateJsdoc';\n\nconst {\n  flow: commentFlow,\n} = transforms;\n\nconst checkNotAlignedPerTag = (utils, tag, customSpacings) => {\n  /*\n  start +\n  delimiter +\n  postDelimiter +\n  tag +\n  postTag +\n  type +\n  postType +\n  name +\n  postName +\n  description +\n  end +\n  lineEnd\n   */\n  let spacerProps;\n  let contentProps;\n  const mightHaveNamepath = utils.tagMightHaveNamepath(tag.tag);\n  if (mightHaveNamepath) {\n    spacerProps = ['postDelimiter', 'postTag', 'postType', 'postName'];\n    contentProps = ['tag', 'type', 'name', 'description'];\n  } else {\n    spacerProps = ['postDelimiter', 'postTag', 'postType'];\n    contentProps = ['tag', 'type', 'description'];\n  }\n\n  const {tokens} = tag.source[0];\n\n  const followedBySpace = (idx, callbck) => {\n    const nextIndex = idx + 1;\n\n    return spacerProps.slice(nextIndex).some((spacerProp, innerIdx) => {\n      const contentProp = contentProps[nextIndex + innerIdx];\n\n      const spacePropVal = tokens[spacerProp];\n\n      const ret = spacePropVal;\n\n      if (callbck) {\n        callbck(!ret, contentProp);\n      }\n\n      return ret && (callbck || !contentProp);\n    });\n  };\n\n  // If checking alignment on multiple lines, need to check other `source`\n  //   items\n  // Go through `post*` spacing properties and exit to indicate problem if\n  //   extra spacing detected\n  const ok = !spacerProps.some((spacerProp, idx) => {\n    const contentProp = contentProps[idx];\n    const contentPropVal = tokens[contentProp];\n    const spacerPropVal = tokens[spacerProp];\n    const spacing = customSpacings?.[spacerProp] || 1;\n\n    // There will be extra alignment if...\n\n    // 1. The spaces don't match the space it should have (1 or custom spacing) OR\n    return spacerPropVal.length !== spacing && spacerPropVal.length !== 0 ||\n\n      // 2. There is a (single) space, no immediate content, and yet another\n      //     space is found subsequently (not separated by intervening content)\n      spacerPropVal && !contentPropVal && followedBySpace(idx);\n  });\n  if (ok) {\n    return;\n  }\n\n  const fix = () => {\n    for (const [idx, spacerProp] of spacerProps.entries()) {\n      const contentProp = contentProps[idx];\n      const contentPropVal = tokens[contentProp];\n\n      if (contentPropVal) {\n        const spacing = customSpacings?.[spacerProp] || 1;\n        tokens[spacerProp] = ''.padStart(spacing, ' ');\n        followedBySpace(idx, (hasSpace, contentPrp) => {\n          if (hasSpace) {\n            tokens[contentPrp] = '';\n          }\n        });\n      } else {\n        tokens[spacerProp] = '';\n      }\n    }\n\n    utils.setTag(tag, tokens);\n  };\n\n  utils.reportJSDoc('Expected JSDoc block lines to not be aligned.', tag, fix, true);\n};\n\nconst checkAlignment = ({\n  customSpacings,\n  indent,\n  jsdoc,\n  jsdocNode,\n  preserveMainDescriptionPostDelimiter,\n  report,\n  tags,\n  utils,\n}) => {\n  const transform = commentFlow(\n    alignTransform({\n      customSpacings,\n      indent,\n      preserveMainDescriptionPostDelimiter,\n      tags,\n    }),\n  );\n  const transformedJsdoc = transform(jsdoc);\n\n  const comment = '/*' + jsdocNode.value + '*/';\n  const formatted = utils.stringify(transformedJsdoc)\n    .trimStart();\n\n  if (comment !== formatted) {\n    report(\n      'Expected JSDoc block lines to be aligned.',\n      (fixer) => {\n        return fixer.replaceText(jsdocNode, formatted);\n      },\n    );\n  }\n};\n\nexport default iterateJsdoc(({\n  indent,\n  jsdoc,\n  jsdocNode,\n  report,\n  context,\n  utils,\n}) => {\n  const {\n    tags: applicableTags = ['param', 'arg', 'argument', 'property', 'prop', 'returns', 'return'],\n    preserveMainDescriptionPostDelimiter,\n    customSpacings,\n  } = context.options[1] || {};\n\n  if (context.options[0] === 'always') {\n    // Skip if it contains only a single line.\n    if (!jsdocNode.value.includes('\\n')) {\n      return;\n    }\n\n    checkAlignment({\n      customSpacings,\n      indent,\n      jsdoc,\n      jsdocNode,\n      preserveMainDescriptionPostDelimiter,\n      report,\n      tags: applicableTags,\n      utils,\n    });\n\n    return;\n  }\n\n  const foundTags = utils.getPresentTags(applicableTags);\n  for (const tag of foundTags) {\n    checkNotAlignedPerTag(utils, tag, customSpacings);\n  }\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Reports invalid alignment of JSDoc block lines.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc#eslint-plugin-jsdoc-rules-check-line-alignment',\n    },\n    fixable: 'whitespace',\n    schema: [\n      {\n        enum: ['always', 'never'],\n        type: 'string',\n      },\n      {\n        additionalProperties: false,\n        properties: {\n          customSpacings: {\n            additionalProperties: false,\n            properties: {\n              postDelimiter: {\n                type: 'integer',\n              },\n              postName: {\n                type: 'integer',\n              },\n              postTag: {\n                type: 'integer',\n              },\n              postType: {\n                type: 'integer',\n              },\n            },\n          },\n          preserveMainDescriptionPostDelimiter: {\n            default: false,\n            type: 'boolean',\n          },\n          tags: {\n            items: {\n              type: 'string',\n            },\n            type: 'array',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'layout',\n  },\n});\n"],"file":"checkLineAlignment.js"}