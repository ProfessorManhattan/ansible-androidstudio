"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadSchema = exports.urlToSchemastoreFilePath = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const http_client_1 = require("./http-client");
const debug_1 = __importDefault(require("debug"));
const json_schema_migrate_1 = require("json-schema-migrate");
const debug = (0, debug_1.default)("eslint-plugin-json-schema-validator:utils-schema");
const TTL = 1000 * 60 * 60 * 24;
const RELOADING = new Set();
function urlToSchemastoreFilePath(url) {
    if (/^https?:\/\/json\.schemastore\.org\//u.test(url)) {
        const jsonPath = url.replace(/^https?:\/\//u, "");
        if (jsonPath.endsWith(".json")) {
            return jsonPath;
        }
        return `${jsonPath}.json`;
    }
    return null;
}
exports.urlToSchemastoreFilePath = urlToSchemastoreFilePath;
function loadSchema(schemaPath, context) {
    if (schemaPath.startsWith("http://") || schemaPath.startsWith("https://")) {
        const jsonPath = urlToSchemastoreFilePath(schemaPath);
        if (!jsonPath) {
            return loadSchemaFromURL(schemaPath, context);
        }
        try {
            return require(`../../schemastore/${jsonPath}`);
        }
        catch (_a) {
        }
        return loadSchemaFromURL(schemaPath, context);
    }
    const json = fs_1.default.readFileSync(path_1.default.resolve(getCwd(context), schemaPath), "utf-8");
    const schema = JSON.parse(json);
    (0, json_schema_migrate_1.draft7)(schema);
    return schema;
}
exports.loadSchema = loadSchema;
function loadSchemaFromURL(schemaUrl, context) {
    var _a, _b, _c;
    let jsonPath = schemaUrl.replace(/^https?:\/\//u, "");
    if (!jsonPath.endsWith(".json")) {
        jsonPath = `${jsonPath}.json`;
    }
    const jsonFilePath = path_1.default.join(__dirname, `../../.cached_schemastore/${jsonPath}`);
    const options = (_b = (_a = context.settings) === null || _a === void 0 ? void 0 : _a["json-schema-validator"]) === null || _b === void 0 ? void 0 : _b.http;
    const httpRequestOptions = (_c = options === null || options === void 0 ? void 0 : options.requestOptions) !== null && _c !== void 0 ? _c : {};
    const httpGetModulePath = resolvePath(options === null || options === void 0 ? void 0 : options.getModulePath, context);
    makeDirs(path_1.default.dirname(jsonFilePath));
    if (fs_1.default.existsSync(jsonFilePath)) {
        const { schema, timestamp } = require(jsonFilePath);
        if (schema != null && typeof timestamp === "number") {
            if (timestamp + TTL < Date.now()) {
                if (!RELOADING.has(schemaUrl)) {
                    RELOADING.add(schemaUrl);
                    (0, http_client_1.get)(schemaUrl, httpRequestOptions, httpGetModulePath).then((json) => {
                        postProcess(schemaUrl, jsonFilePath, json, context);
                        RELOADING.delete(schemaUrl);
                    });
                }
            }
            return schema;
        }
    }
    let json;
    try {
        json = (0, http_client_1.syncGet)(schemaUrl, httpRequestOptions, httpGetModulePath);
    }
    catch (e) {
        debug(e.message);
        return null;
    }
    return postProcess(schemaUrl, jsonFilePath, json, context);
}
function postProcess(schemaUrl, jsonFilePath, json, context) {
    let schema;
    try {
        schema = JSON.parse(json);
    }
    catch (_a) {
        context.report({
            loc: { line: 1, column: 0 },
            message: `Could not be parsed JSON: "${schemaUrl}"`,
        });
        return null;
    }
    (0, json_schema_migrate_1.draft7)(schema);
    fs_1.default.writeFileSync(jsonFilePath, schemaStringify({
        schema,
        timestamp: Date.now(),
        v: require("../../package.json").version,
    }));
    delete require.cache[jsonFilePath];
    return schema;
}
function makeDirs(dir) {
    const dirs = [dir];
    while (!fs_1.default.existsSync(dirs[0])) {
        dirs.unshift(path_1.default.dirname(dirs[0]));
    }
    dirs.shift();
    for (const dir of dirs) {
        fs_1.default.mkdirSync(dir);
    }
}
function schemaStringify(schema) {
    return JSON.stringify(schema, (_key, value) => {
        return value;
    });
}
function resolvePath(modulePath, context) {
    if (!modulePath) {
        return undefined;
    }
    if (modulePath.startsWith(".")) {
        return path_1.default.join(getCwd(context), modulePath);
    }
    return modulePath;
}
function getCwd(context) {
    if (context.getCwd) {
        return context.getCwd();
    }
    return path_1.default.resolve("");
}
