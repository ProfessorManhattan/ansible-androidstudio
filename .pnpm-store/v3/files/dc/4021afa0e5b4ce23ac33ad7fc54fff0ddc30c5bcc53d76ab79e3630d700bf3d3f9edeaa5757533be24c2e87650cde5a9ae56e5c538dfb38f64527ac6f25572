"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getJSONNodeFromPath = void 0;
const TRAVERSE_TARGET_TYPE = new Set([
    "Program",
    "JSONExpressionStatement",
    "JSONObjectExpression",
    "JSONArrayExpression",
]);
const GET_JSON_NODES = {
    Program(node, _paths) {
        return { value: node.body[0] };
    },
    JSONExpressionStatement(node, _paths) {
        return { value: node.expression };
    },
    JSONObjectExpression(node, paths) {
        const path = String(paths.shift());
        for (const prop of node.properties) {
            if (prop.key.type === "JSONIdentifier") {
                if (prop.key.name === path) {
                    return { key: () => prop.key.range, value: prop.value };
                }
            }
            else {
                if (String(prop.key.value) === path) {
                    return { key: () => prop.key.range, value: prop.value };
                }
            }
        }
        throw new Error(`${"Unexpected state: ["}${[path, ...paths].join(", ")}]`);
    },
    JSONArrayExpression(node, paths) {
        const path = String(paths.shift());
        for (let index = 0; index < node.elements.length; index++) {
            if (String(index) !== path) {
                continue;
            }
            const element = node.elements[index];
            if (element) {
                return { value: element };
            }
            return {
                key: (sourceCode) => {
                    const before = node.elements
                        .slice(0, index)
                        .reverse()
                        .find((n) => n != null);
                    let tokenIndex = before ? node.elements.indexOf(before) : -1;
                    let token = before
                        ? sourceCode.getTokenAfter(before)
                        : sourceCode.getFirstToken(node);
                    while (tokenIndex < index) {
                        tokenIndex++;
                        token = sourceCode.getTokenAfter(token);
                    }
                    return [
                        sourceCode.getTokenBefore(token).range[1],
                        token.range[0],
                    ];
                },
                value: null,
            };
        }
        throw new Error(`${"Unexpected state: ["}${[path, ...paths].join(", ")}]`);
    },
};
function getJSONNodeFromPath(node, [...paths]) {
    let data = {
        key: (sourceCode) => {
            const dataNode = node.body[0].expression;
            if (dataNode.type === "JSONObjectExpression" ||
                dataNode.type === "JSONArrayExpression") {
                return sourceCode.getFirstToken(dataNode).range;
            }
            return dataNode.range;
        },
        value: node,
    };
    while (paths.length && data.value) {
        if (!isTraverseTarget(data.value)) {
            throw new Error(`Unexpected node type: ${data.value.type}`);
        }
        data = GET_JSON_NODES[data.value.type](data.value, paths);
    }
    return data;
}
exports.getJSONNodeFromPath = getJSONNodeFromPath;
function isTraverseTarget(node) {
    return TRAVERSE_TARGET_TYPE.has(node.type);
}
