"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.maxBitToMaxValues = void 0;
const utils_1 = require("../utils");
const cacheMaxValues = {};
function maxBitToMaxValues(maxBit) {
    const binaryMax = [];
    const minusMax = [0];
    const plusMax = [0];
    const hexMax = [0];
    const octalMax = [0];
    for (let index = 0; index < maxBit; index++) {
        const binaryNum = index === 0 ? 1 : 0;
        binaryMax.push(binaryNum);
        processDigits(minusMax, binaryNum, 10);
        processDigits(hexMax, binaryNum, 16);
        processDigits(octalMax, binaryNum, 8);
        if (index > 0) {
            processDigits(plusMax, 1, 10);
        }
    }
    return {
        "+": plusMax.reverse().join(""),
        "-": minusMax.reverse().join(""),
        "0x": hexMax
            .map((i) => i.toString(16))
            .reverse()
            .join("")
            .toLowerCase(),
        "0o": octalMax.reverse().join(""),
        "0b": binaryMax.join(""),
    };
    function processDigits(digits, binaryNum, radix) {
        let num = binaryNum;
        for (let place = 0; place < digits.length; place++) {
            num = digits[place] * 2 + num;
            digits[place] = num % radix;
            num = Math.floor(num / radix);
        }
        while (num > 0) {
            digits.push(num % radix);
            num = Math.floor(num / radix);
        }
    }
}
exports.maxBitToMaxValues = maxBitToMaxValues;
function getMaxValues(bit) {
    if (cacheMaxValues[bit]) {
        return cacheMaxValues[bit];
    }
    return (cacheMaxValues[bit] = maxBitToMaxValues(bit));
}
exports.default = utils_1.createRule("precision-of-integer", {
    meta: {
        docs: {
            description: "disallow precision of integer greater than the specified value.",
            categories: ["recommended", "standard"],
            extensionRule: false,
        },
        schema: [
            {
                type: "object",
                properties: {
                    maxBit: {
                        type: "number",
                        minimum: 1,
                    },
                },
                additionalProperties: false,
            },
        ],
        messages: {
            over: "Integers with precision greater than {{maxBit}}-bit are forbidden.",
        },
        type: "problem",
    },
    create(context) {
        var _a, _b;
        if (!context.parserServices.isTOML) {
            return {};
        }
        const maxBit = (_b = (_a = context.options[0]) === null || _a === void 0 ? void 0 : _a.maxBit) !== null && _b !== void 0 ? _b : 64;
        const maxValues = getMaxValues(maxBit);
        function verifyMaxValue(node, numText, max) {
            const num = numText.replace(/^0+/, "").toLowerCase();
            if (num.length < max.length) {
                return;
            }
            if (num.length === max.length && num <= max) {
                return;
            }
            context.report({
                node,
                messageId: "over",
                data: {
                    maxBit,
                },
            });
        }
        function verifyText(node) {
            const text = node.number;
            if (text.startsWith("0")) {
                const maybeMark = text[1];
                if (maybeMark === "x") {
                    verifyMaxValue(node, text.slice(2), maxValues["0x"]);
                    return;
                }
                else if (maybeMark === "o") {
                    verifyMaxValue(node, text.slice(2), maxValues["0o"]);
                    return;
                }
                else if (maybeMark === "b") {
                    verifyMaxValue(node, text.slice(2), maxValues["0b"]);
                    return;
                }
            }
            else if (text.startsWith("-")) {
                verifyMaxValue(node, text.slice(1), maxValues["-"]);
                return;
            }
            else if (text.startsWith("+")) {
                verifyMaxValue(node, text.slice(1), maxValues["+"]);
                return;
            }
            verifyMaxValue(node, text, maxValues["+"]);
        }
        return {
            TOMLValue(node) {
                if (node.kind === "integer") {
                    verifyText(node);
                }
            },
        };
    },
});
