{"version":3,"sources":["index.js"],"names":["Object","defineProperty","exports","value","primitives_1","require","util_1","block_parser_1","source_parser_1","spec_parser_1","tag_1","type_1","name_1","description_1","getParser","startLine","fence","spacing","markers","Markers","tokenizers","default","Error","parseSource","parseBlock","parseSpec","joinDescription","getJoiner","notEmpty","line","tokens","description","trim","source","blocks","splitLines","lines","find","undefined","sections","specs","slice","map","push","tags","problems","reduce","acc","spec","concat"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,YAAY,GAAGC,OAAH,qBAAlB;;AACA,MAAMC,MAAM,GAAGD,OAAH,eAAZ;;AACA,MAAME,cAAc,GAAGF,OAAH,sBAApB;;AACA,MAAMG,eAAe,GAAGH,OAAH,uBAArB;;AACA,MAAMI,aAAa,GAAGJ,OAAH,qBAAnB;;AACA,MAAMK,KAAK,GAAGL,OAAH,wBAAX;;AACA,MAAMM,MAAM,GAAGN,OAAH,yBAAZ;;AACA,MAAMO,MAAM,GAAGP,OAAH,yBAAZ;;AACA,MAAMQ,aAAa,GAAGR,OAAH,gCAAnB;;AACA,SAASS,SAAT,CAAmB;AAAEC,EAAAA,SAAS,GAAG,CAAd;AAAiBC,EAAAA,KAAK,GAAG,KAAzB;AAAgCC,EAAAA,OAAO,GAAG,SAA1C;AAAqDC,EAAAA,OAAO,GAAGd,YAAY,CAACe,OAA5E;AAAqFC,EAAAA,UAAU,GAAG,CACjHV,KAAK,CAACW,OAAN,EADiH,EAEjHV,MAAM,CAACU,OAAP,CAAeJ,OAAf,CAFiH,EAGjHL,MAAM,CAACS,OAAP,EAHiH,EAIjHR,aAAa,CAACQ,OAAd,CAAsBJ,OAAtB,CAJiH;AAAlG,IAKZ,EALP,EAKW;AACP,MAAIF,SAAS,GAAG,CAAZ,IAAiBA,SAAS,GAAG,CAAZ,GAAgB,CAArC,EACI,MAAM,IAAIO,KAAJ,CAAU,mBAAV,CAAN;AACJ,QAAMC,WAAW,GAAGf,eAAe,CAACa,OAAhB,CAAwB;AAAEN,IAAAA,SAAF;AAAaG,IAAAA;AAAb,GAAxB,CAApB;AACA,QAAMM,UAAU,GAAGjB,cAAc,CAACc,OAAf,CAAuB;AAAEL,IAAAA;AAAF,GAAvB,CAAnB;AACA,QAAMS,SAAS,GAAGhB,aAAa,CAACY,OAAd,CAAsB;AAAED,IAAAA;AAAF,GAAtB,CAAlB;AACA,QAAMM,eAAe,GAAGb,aAAa,CAACc,SAAd,CAAwBV,OAAxB,CAAxB;;AACA,QAAMW,QAAQ,GAAIC,IAAD,IAAUA,IAAI,CAACC,MAAL,CAAYC,WAAZ,CAAwBC,IAAxB,MAAkC,EAA7D;;AACA,SAAO,UAAUC,MAAV,EAAkB;AACrB,UAAMC,MAAM,GAAG,EAAf;;AACA,SAAK,MAAML,IAAX,IAAmBvB,MAAM,CAAC6B,UAAP,CAAkBF,MAAlB,CAAnB,EAA8C;AAC1C,YAAMG,KAAK,GAAGb,WAAW,CAACM,IAAD,CAAzB;AACA,UAAIO,KAAK,KAAK,IAAd,EACI;AACJ,UAAIA,KAAK,CAACC,IAAN,CAAWT,QAAX,MAAyBU,SAA7B,EACI;AACJ,YAAMC,QAAQ,GAAGf,UAAU,CAACY,KAAD,CAA3B;AACA,YAAMI,KAAK,GAAGD,QAAQ,CAACE,KAAT,CAAe,CAAf,EAAkBC,GAAlB,CAAsBjB,SAAtB,CAAd;AACAS,MAAAA,MAAM,CAACS,IAAP,CAAY;AACRZ,QAAAA,WAAW,EAAEL,eAAe,CAACa,QAAQ,CAAC,CAAD,CAAT,EAAcrB,OAAd,CADpB;AAER0B,QAAAA,IAAI,EAAEJ,KAFE;AAGRP,QAAAA,MAAM,EAAEG,KAHA;AAIRS,QAAAA,QAAQ,EAAEL,KAAK,CAACM,MAAN,CAAa,CAACC,GAAD,EAAMC,IAAN,KAAeD,GAAG,CAACE,MAAJ,CAAWD,IAAI,CAACH,QAAhB,CAA5B,EAAuD,EAAvD;AAJF,OAAZ;AAMH;;AACD,WAAOX,MAAP;AACH,GAlBD;AAmBH;;AACDhC,OAAO,CAACmB,OAAR,GAAkBP,SAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst primitives_1 = require(\"../primitives\");\nconst util_1 = require(\"../util\");\nconst block_parser_1 = require(\"./block-parser\");\nconst source_parser_1 = require(\"./source-parser\");\nconst spec_parser_1 = require(\"./spec-parser\");\nconst tag_1 = require(\"./tokenizers/tag\");\nconst type_1 = require(\"./tokenizers/type\");\nconst name_1 = require(\"./tokenizers/name\");\nconst description_1 = require(\"./tokenizers/description\");\nfunction getParser({ startLine = 0, fence = '```', spacing = 'compact', markers = primitives_1.Markers, tokenizers = [\n    tag_1.default(),\n    type_1.default(spacing),\n    name_1.default(),\n    description_1.default(spacing),\n], } = {}) {\n    if (startLine < 0 || startLine % 1 > 0)\n        throw new Error('Invalid startLine');\n    const parseSource = source_parser_1.default({ startLine, markers });\n    const parseBlock = block_parser_1.default({ fence });\n    const parseSpec = spec_parser_1.default({ tokenizers });\n    const joinDescription = description_1.getJoiner(spacing);\n    const notEmpty = (line) => line.tokens.description.trim() != '';\n    return function (source) {\n        const blocks = [];\n        for (const line of util_1.splitLines(source)) {\n            const lines = parseSource(line);\n            if (lines === null)\n                continue;\n            if (lines.find(notEmpty) === undefined)\n                continue;\n            const sections = parseBlock(lines);\n            const specs = sections.slice(1).map(parseSpec);\n            blocks.push({\n                description: joinDescription(sections[0], markers),\n                tags: specs,\n                source: lines,\n                problems: specs.reduce((acc, spec) => acc.concat(spec.problems), []),\n            });\n        }\n        return blocks;\n    };\n}\nexports.default = getParser;\n"],"file":"index.cjs"}