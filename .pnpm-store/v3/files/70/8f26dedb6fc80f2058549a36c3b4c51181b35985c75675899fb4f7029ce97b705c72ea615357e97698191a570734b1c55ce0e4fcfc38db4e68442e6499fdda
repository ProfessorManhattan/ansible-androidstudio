"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.customTransformer = void 0;
const commit_types_1 = require("./commit-types");
const COMMIT_HASH_LENGTH = 7;
function customTransformer(commit, context) {
    const types = commit_types_1.commitTypes;
    if (commit.notes) {
        commit.notes.forEach((note) => {
            note.title = 'Breaking changes';
        });
    }
    if (types.types[commit.type] && (types.types[commit.type].changelog || (commit.notes && commit.notes.length > 0))) {
        commit.groupType = `${types.types[commit.type].emoji ? `${types.types[commit.type].emoji} ` : ''}${types.types[commit.type].title}`;
    }
    else {
        return null;
    }
    if (commit.scope === '*') {
        commit.scope = '';
    }
    if (typeof commit.hash === 'string') {
        commit.shortHash = commit.hash.slice(0, COMMIT_HASH_LENGTH);
    }
    const references = [];
    if (typeof commit.subject === 'string') {
        let url = context.repository ? `${context.host}/${context.owner}/${context.repository}` : context.repoUrl;
        if (url) {
            url += '/issues/';
            commit.subject = commit.subject.replace(/#(\d+)/gu, (_unused, issue) => {
                references.push(issue);
                return `[#${issue}](${url}${issue})`;
            });
        }
        if (context.host) {
            commit.subject = commit.subject.replace(/\B@([\da-z](?:-?[\da-z]){0,38})/gu, `[@$1](${context.host}/$1)`);
        }
    }
    if (commit.references) {
        commit.references = commit.references.filter((reference) => {
            if (!references.includes(reference.issue)) {
                return true;
            }
            return false;
        });
    }
    return commit;
}
exports.customTransformer = customTransformer;
//# sourceMappingURL=custom-transformer.js.map